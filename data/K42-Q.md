### Low Risk Report for [Panoptic](https://github.com/code-423n4/2024-09-panoptic)

### Low Risk Issues

| ID   | Title                                                                           | Severity | Proof of Concept | Impact | Recommended Mitigation                               |
| ---- | ------------------------------------------------------------------------------- | -------- | ---------------- | ------ | ---------------------------------------------------- |
| L-01 | No use of Address(0) checks in `PanopticFactory.Constructor`                    | Low      | See below        | Medium | Use Address(0) check in constructor                  |
| L-02 | No specific error message for PanopticPool's access control                     | Low      | See below        | Low    | Good to use error message for access control         |
| L-03 | Overly permissive behaviour in `PanopticFactory.deployNewPool()`                | Low      | See below        | Medium | Use some stricter validation for critical parameters |
| L-04 | Unexpected revert in `PanopticFactory.minePoolAddress()` for Maximum Salt Value | Low      | See below        | Low    | Handle maximum salt value more gracefully            |

### [LOWS]:

#### L-01:  No use of Address(0) checks in `PanopticFactory.Constructor`

`PanopticFactory.constructor` doesnt validate its input parameters so that critical addresses are not set to the Address(0).

**Proof of Concept:**
[PanopticFactory.sol](https://github.com/code-423n4/2024-09-panoptic/blob/main/contracts/PanopticFactory.sol#L105)

```solidity
constructor(
    address _WETH9,
    SemiFungiblePositionManager _SFPM,
    IUniswapV3Factory _univ3Factory,
    address _poolReference,
    address _collateralReference,
    bytes32[] memory properties,
    uint256[][] memory indices,
    Pointer[][] memory pointers
) FactoryNFT(properties, indices, pointers) {
    WETH = _WETH9;
    SFPM = _SFPM;
    UNIV3_FACTORY = _univ3Factory;
    POOL_REFERENCE = _poolReference;
    COLLATERAL_REFERENCE = _collateralReference;
}
```

**PoC Test Function:**
```solidity
function test_Fail_PanopticFactory_ZeroAddressCheck() public {
    vm.expectRevert();
    new PanopticFactory(
        address(0),  // WETH
        SemiFungiblePositionManager(address(0)),  // SFPM
        IUniswapV3Factory(address(0)),  // UNIV3_FACTORY
        address(0),  // POOL_REFERENCE
        address(0),  // COLLATERAL_REFERENCE
        new bytes32[](0),
        new uint256[][](0),
        new Pointer[][](0)
    );
}
```

**Test Output:**
```
Failing tests:
Encountered 1 failing test in test/foundry/core/PanopticPool.t.sol:PanopticPoolTest
[FAIL. Reason: call did not revert as expected] test_Fail_PanopticFactory_ZeroAddressCheck() (gas: 3243832)
```

**Impact:** 
Deployed factory contract that doesn't function correctly, as it would be referencing non-existent contracts for key components of its operation.

**Recommended Mitigation:**
Use Address(0) check in constructor:

```solidity
constructor(
    address _WETH9,
    SemiFungiblePositionManager _SFPM,
    IUniswapV3Factory _univ3Factory,
    address _poolReference,
    address _collateralReference,
    bytes32[] memory properties,
    uint256[][] memory indices,
    Pointer[][] memory pointers
) FactoryNFT(properties, indices, pointers) {
    require(_WETH9 != address(0), "WETH9 cannot be zero address");
    require(address(_SFPM) != address(0), "SFPM cannot be zero address");
    require(address(_univ3Factory) != address(0), "UNIV3_FACTORY cannot be zero address");
    require(_poolReference != address(0), "POOL_REFERENCE cannot be zero address");
    require(_collateralReference != address(0), "COLLATERAL_REFERENCE cannot be zero address");
    WETH = _WETH9;
    SFPM = _SFPM;
    UNIV3_FACTORY = _univ3Factory;
    POOL_REFERENCE = _poolReference;
    COLLATERAL_REFERENCE = _collateralReference;
}
```

#### L-02: No specific error message for PanopticPool's access control 

`PanopticPool.startPool`  doesn't provide a specific error message when reverting unauthorized calls. Given access control. This makes debugging and interacting with the contract more minimally more difficult.

**Proof of Concept:**
[PanopticPool.sol](https://github.com/code-423n4/2024-09-panoptic/blob/main/contracts/PanopticPool.sol#L264)

```solidity
   function startPool(
        IUniswapV3Pool _univ3pool,
        address token0,
        address token1,
        CollateralTracker collateralTracker0,
        CollateralTracker collateralTracker1
    ) external {
        // reverts if the Uniswap pool has already been initialized
        if (address(s_univ3pool) != address(0)) revert Errors.PoolAlreadyInitialized();

        // Store the univ3Pool variable
        s_univ3pool = IUniswapV3Pool(_univ3pool);

        (, int24 currentTick, , , , , ) = IUniswapV3Pool(_univ3pool).slot0();

        // Store the median data
        unchecked {
            s_miniMedian =
                (uint256(block.timestamp) << 216) +
                // magic number which adds (7,5,3,1,0,2,4,6) order and minTick in positions 7, 5, 3 and maxTick in 6, 4, 2
                // see comment on s_miniMedian initialization for format of this magic number
                (uint256(0xF590A6F276170D89E9F276170D89E9F276170D89E9000000000000)) +
                (uint256(uint24(currentTick)) << 24) + // add to slot 4
                (uint256(uint24(currentTick))); // add to slot 3
        }

        // Store the collateral token0
        s_collateralToken0 = collateralTracker0;
        s_collateralToken1 = collateralTracker1;

        // consolidate all 4 approval calls to one library delegatecall in order to reduce bytecode size
        // approves:
        // SFPM: token0, token1
        // CollateralTracker0 - token0
        // CollateralTracker1 - token1
        InteractionHelper.doApprovals(SFPM, collateralTracker0, collateralTracker1, token0, token1);
    }
```

**PoC:**
```solidity
function test_Fail_PanopticPool_StartPoolAccessControl() public {
    PanopticPoolHarness newPP = new PanopticPoolHarness(sfpm);
    
    vm.prank(address(0xdead));
    vm.expectRevert("Unauthorized");
    newPP.startPool(pool, token0, token1, ct0, ct1);
}
```

**Test Output:**
```
[FAIL. Reason: call reverted as expected, but without data] test_Fail_PanopticPool_StartPoolAccessControl() (gas: 5004268)
```

**Impact:** 
Confusion during development, testing, or when interacting with the contract.

**Recommended Mitigation:**
Good to use error message for access control:

```solidity
function startPool(
    IUniswapV3Pool _univ3pool,
    address _token0,
    address _token1,
    CollateralTracker _collateralToken0,
    CollateralTracker _collateralToken1
) external {
    require(msg.sender == authorizedAddress, "PanopticPool: caller is not authorized");
    // same
}
```

#### L-03: Overly permissive behaviour in `PanopticFactory.deployNewPool()`

`PanopticFactory.deployNewPool` is more permissive than expected, allowing operations that were intended to be restricted, like using empty arrays. This opens the contract up to unexpected contract states or subtle vectors.

**Proof of Concept:**
[PanopticFactory.sol](https://github.com/code-423n4/2024-09-panoptic/blob/main/contracts/PanopticFactory.sol#L171)

```solidity
function deployNewPool(
    address token0,
    address token1,
    uint24 fee,
    uint96 salt,
    uint256 amount0Max,
    uint256 amount1Max
) external returns (PanopticPool newPoolContract) {
    // same
}
```

**PoC Test Function:**
```solidity
function test_Fail_PanopticFactory_DeployNewPoolEmptyArrays() public {
    vm.prank(Deployer);
    vm.expectRevert("Empty arrays not allowed");
    factory.deployNewPool(
        token0,
        token1,
        fee,
        0,
        type(uint256).max,
        type(uint256).max
    );
}
```

**Test Output:**
```
[FAIL. Reason: call did not revert as expected] test_Fail_PanopticFactory_DeployNewPoolEmptyArrays() (gas: 19026)
```

**Impact:** 
Unexpected behaviour or errors if critical parameters are not properly validated, resulting in deployed pools with unintended configurations.

**Recommended Mitigation:**
Use some stricter validation for critical parameters:

```solidity
function deployNewPool(
    address token0,
    address token1,
    uint24 fee,
    uint96 salt,
    uint256 amount0Max,
    uint256 amount1Max
) external returns (PanopticPool newPoolContract) {
    require(token0 != address(0) && token1 != address(0), "Invalid token addresses");
    require(fee > 0, "Fee must be greater than 0");
    require(amount0Max > 0 && amount1Max > 0, "Max amounts must be greater than 0");
    // same 
}
```

#### L-04: Unexpected revert in `PanopticFactory.minePoolAddress()` for Maximum Salt Value

`PanopticFactory.minePoolAddress`  is not gracefully handling the case where the initial salt value is at its maximum.

**Proof of Concept:**
[PanopticFactory.sol](https://github.com/code-423n4/2024-09-panoptic/blob/main/contracts/PanopticFactory.sol#L259)

```solidity
function minePoolAddress(
    address deployerAddress,
    address v3Pool,
    uint96 salt,
    uint256 loops,
    uint256 minTargetRarity
) external view returns (uint96 bestSalt, uint256 highestRarity) {
    // Current implementation without handling for maximum salt value
}
```

**PoC Test Function:**
```solidity
function test_Fail_PanopticFactory_MinePoolAddressOverflow() public {
    vm.prank(Deployer);
    (uint96 bestSalt, uint256 highestRarity) = factory.minePoolAddress(
        address(this),
        address(pool),
        type(uint96).max,  // Start with the maximum value
        1000,
        10
    );
    assertEq(bestSalt, type(uint96).max, "Salt should not have changed due to overflow");
    assertEq(highestRarity, 0, "No valid address should have been found");
}
```

**Test Output:**
```
[FAIL. Reason: EvmError: Revert] test_Fail_PanopticFactory_MinePoolAddressOverflow() (gas: 13508)
```

**Impact:** 
Issues in scenarios where the contract is trying to find a suitable salt value starting from a very high number. It might prevent the contract from finding valid addresses in certain suttle edge cases.

**Recommended Mitigation:**
Handle maximum salt value more gracefully:

```solidity
function minePoolAddress(
    address deployerAddress,
    address v3Pool,
    uint96 salt,
    uint256 loops,
    uint256 minTargetRarity
) external view returns (uint96 bestSalt, uint256 highestRarity) {
    if (salt == type(uint96).max) {
        return (salt, 0);  // Return immediately if we're at the max value
    }
    // same
}
```
